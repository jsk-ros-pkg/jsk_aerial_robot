#!/usr/bin/env python

from __future__ import print_function

import re
import socket
import sys
from copy import deepcopy

import roslaunch
import roslaunch.loader
from roslaunch.xmlloader import XmlLoader
from roslaunch.core import printlog, printerrlog, _printerrlog_handlers
from roslaunch.remoteprocess import SSHChildROSLaunchProcess

SSHChildROSLaunchProcess.line_buf_info = ""
SSHChildROSLaunchProcess.line_buf_err = ""

def printlog_raw(msg, file=sys.stderr):
    for h in _printerrlog_handlers:
        try:
            h(msg)
        except:
            pass
    try:
        print(msg, file=sys.stderr)
    except:
        pass


ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')


def patched_is_alive(self):
    """
    :returns: ``True`` if the process is alive. is_alive needs to be
        called periodically as it drains the SSH buffer, ``bool``
    """
    filter_keywords = ["TF_REPEATED_DATA"]
    if self.started and not self.ssh:
        return False
    elif not self.started:
        return True  # not started is equivalent to alive in our logic
    s = self.ssherr
    s.channel.settimeout(0)
    try:
        # drain the pipes
        data = s.read(256)
        if not len(data):
            self.is_dead = True
            return False
        data = data.decode('utf-8')
        lines = data.split("\n")
        if len(lines) > 0:
            if len(self.line_buf_err) > 0:
                lines[0] = self.line_buf_err + lines[0]
                self.line_buf_err = ""
            if data[-1] != "\n":
                self.line_buf_err = lines[-1]
                lines = lines[:-1]
            for line in lines:
                if any(keyword in line for keyword in filter_keywords):
                    continue                
                if line.startswith("\033") and len(line) >= 5:
                    print(line[:(5 if line[4] == "m" else 4)] + "remote[%s]:\033[0m %s" % (self.name, line))
                elif len(ansi_escape.sub('', line).strip()) > 0:
                    print("remote[%s]: %s" % (self.name, line))
                # if line.startswith("\033") and len(line) >= 5:
                #     printlog_raw(line[:(5 if line[4] == "m" else 4)] + "remote[%s]:\033[0m %s" % (self.name, line), file=sys.stderr)
                # elif len(ansi_escape.sub('', line).strip()) > 0:
                #     printerrlog("remote[%s]: %s" % (self.name, line))
    except socket.timeout:
        pass
    except IOError:
        return False
    except UnicodeDecodeError:
        # #2012: soft fail, printing is not essential. This occurs
        # with older machines that don't send utf-8 over ssh
        pass

    s = self.sshout
    s.channel.settimeout(0)
    try:
        # drain the pipes
        data = s.read(128)
        if not len(data):
            self.is_dead = True
            return False
        # #2012 il8n: ssh *should* be UTF-8, but often isn't
        # (e.g. Japan)
        data = data.decode('utf-8')
        lines = data.split("\n")
        if len(lines) > 0:
            if len(self.line_buf_info) > 0:
                lines[0] = self.line_buf_info + lines[0]
                self.line_buf_info = ""
            if data[-1] != "\n":
                self.line_buf_info = lines[-1]
                lines = lines[:-1]
            for line in lines:
                if any(keyword in line for keyword in filter_keywords):
                    continue        
                if line.startswith("\033") and len(line) >= 5:
                    print(line[:(5 if line[4] == "m" else 4)] + "remote[%s]:\033[0m %s" % (self.name, line))
                elif len(ansi_escape.sub('', line).strip()) > 0:
                    print("remote[%s]: %s" % (self.name, line))
                # print(line)
                # if line.startswith("\033") and len(line) >= 5:
                #     printlog_raw(line[:(5 if line[4] == "m" else 4)] + "remote[%s]:\033[0m %s" % (self.name, line), file=sys.stdout)
                # elif len(ansi_escape.sub('', line).strip()) > 0:
                #     printerrlog("remote[%s]: %s" % (self.name, line))
    except socket.timeout:
        pass
    except IOError:
        return False
    return True

SSHChildROSLaunchProcess.is_alive = patched_is_alive


roslaunch.main()
