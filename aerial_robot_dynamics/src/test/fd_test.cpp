#include <aerial_robot_dynamics/robot_model_test.h>
#include <aerial_robot_dynamics/math_utils.h>
#include <chrono>

using namespace aerial_robot_dynamics;

bool PinocchioRobotModelTest::forwardDynamicsTest(bool verbose)
{
  Eigen::VectorXd q = pinocchio::randomConfiguration(*(robot_model_->getModel()));
  Eigen::VectorXd v = Eigen::VectorXd::Ones(robot_model_->getModel()->nv);
  Eigen::VectorXd tau = Eigen::VectorXd::Ones(robot_model_->getModel()->nv);
  Eigen::VectorXd thrust = Eigen::VectorXd::Ones(robot_model_->getRotorNum());

  addNoise(v, 0.1);
  addNoise(tau, 0.1);
  addNoise(thrust, 0.1);

  auto start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd a = robot_model_->forwardDynamics(q, v, tau, thrust);  // calculate FD with thrust
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "FD time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0
            << " ms" << std::endl;

  if (verbose)
  {
    std::cout << "q:" << std::endl;
    std::cout << q.transpose() << std::endl;
    std::cout << "v:" << std::endl;
    std::cout << v.transpose() << std::endl;
    std::cout << "tau:" << std::endl;
    std::cout << tau.transpose() << std::endl;
    std::cout << "thrust:" << std::endl;
    std::cout << thrust.transpose() << std::endl;
    std::cout << "a:" << std::endl;
    std::cout << a.transpose() << std::endl;
  }

  // calculate mass matrix
  pinocchio::crba(*(robot_model_->getModel()), *(robot_model_->getData()), q);
  Eigen::MatrixXd M = robot_model_->getData()->M;
  M.triangularView<Eigen::StrictlyLower>() = M.transpose();

  // calculate generalized gravity
  pinocchio::computeGeneralizedGravity(*(robot_model_->getModel()), *(robot_model_->getData()), q);
  Eigen::VectorXd g = robot_model_->getData()->g;

  // calculate coriolis and centrifugal forces
  pinocchio::nonLinearEffects(*(robot_model_->getModel()), *(robot_model_->getData()), q, v);
  Eigen::VectorXd nle = robot_model_->getData()->nle;
  Eigen::VectorXd Cv = nle - g;

  // calculate general force by rotors
  Eigen::VectorXd rotor_general_force = Eigen::VectorXd::Zero(robot_model_->getModel()->nv);
  for (int i = 0; i < robot_model_->getRotorNum(); i++)
  {
    Eigen::MatrixXd rotor_i_jacobian = Eigen::MatrixXd::Zero(6, robot_model_->getModel()->nv);
    pinocchio::computeFrameJacobian(*(robot_model_->getModel()), *(robot_model_->getData()), q,
                                    robot_model_->getModel()->getFrameId("rotor" + std::to_string(i + 1)),
                                    pinocchio::LOCAL, rotor_i_jacobian);  // LOCAL

    // wrench generated by rotor is expressed LOCAL frame
    Eigen::VectorXd rotor_i_wrench = Eigen::VectorXd::Zero(6);
    rotor_i_wrench.head<3>() = Eigen::Vector3d(0, 0, thrust(i));
    rotor_i_wrench.tail<3>() =
        Eigen::Vector3d(0, 0, robot_model_->getRotorDirection(i) * robot_model_->getMFRate() * thrust(i));

    Eigen::VectorXd rotor_i_general_force = rotor_i_jacobian.transpose() * rotor_i_wrench;
    rotor_general_force += rotor_i_general_force;
  }

  if (verbose)
  {
    std::cout << "M * a + Cv + g: " << std::endl;
    std::cout << (M * a + Cv + g).transpose() << std::endl;
    std::cout << std::endl;
    std::cout << "rotor_general_force: " << std::endl;
    std::cout << rotor_general_force.transpose() << std::endl;
    std::cout << "tau + rotor_general_force: " << std::endl;
    std::cout << (tau + rotor_general_force).transpose() << std::endl;
    std::cout << "error norm: " << (M * a + Cv + g - (tau + rotor_general_force)).norm() << std::endl;
  }

  return (M * a + Cv + g).isApprox(tau + rotor_general_force, 1e-6);
}
