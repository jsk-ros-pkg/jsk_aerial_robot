#include <aerial_robot_dynamics/robot_model.h>
#include <aerial_robot_dynamics/math_utils.h>
#include <chrono>

using namespace aerial_robot_dynamics;

Eigen::VectorXd PinocchioRobotModel::getResetConfiguration()
{
  Eigen::VectorXd q = Eigen::VectorXd::Zero(model_->nq);
  q(6) = 1;
  q(model_->joints[model_->getJointId("joint1_yaw")].idx_q()) = M_PI / 2.0;
  q(model_->joints[model_->getJointId("joint2_yaw")].idx_q()) = M_PI / 2.0;
  q(model_->joints[model_->getJointId("joint3_yaw")].idx_q()) = M_PI / 2.0;

  return q;
}


bool PinocchioRobotModel::forwardDynamicsTest(bool verbose)
{
  Eigen::VectorXd q = pinocchio::randomConfiguration(*model_);
  Eigen::VectorXd v = Eigen::VectorXd::Ones(model_->nv);
  Eigen::VectorXd tau = Eigen::VectorXd::Ones(model_->nv);
  Eigen::VectorXd thrust = Eigen::VectorXd::Ones(rotor_num_);

  addNoise(v, 0.1);
  addNoise(tau, 0.1);
  addNoise(thrust, 0.1);

  auto start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd a = this->forwardDynamics(q, v, tau, thrust); // calculate FD with thrust
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "FD time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  if(verbose)
    {
      std::cout << "q:" << std::endl;
      std::cout << q.transpose() << std::endl;
      std::cout << "v:" << std::endl;
      std::cout << v.transpose() << std::endl;
      std::cout << "tau:" << std::endl;
      std::cout << tau.transpose() << std::endl;
      std::cout << "thrust:" << std::endl;
      std::cout << thrust.transpose() << std::endl;
      std::cout << "a:" << std::endl;
      std::cout << a.transpose() << std::endl;
    }


  // calculate mass matrix
  pinocchio::crba(*model_, *data_, q);
  Eigen::MatrixXd M = data_->M;
  M.triangularView<Eigen::StrictlyLower>() = M.transpose();

  // calculate generalized gravity
  pinocchio::computeGeneralizedGravity(*model_, *data_, q);
  Eigen::VectorXd g = data_->g;

  // calculate coriolis and centrifugal forces
  pinocchio::nonLinearEffects(*model_, *data_, q, v);
  Eigen::VectorXd nle = data_->nle;
  Eigen::VectorXd Cv = nle - g;

  // calculate general force by rotors
  Eigen::VectorXd rotor_general_force = Eigen::VectorXd::Zero(model_->nv);
  for(int i = 0; i < rotor_num_; i++)
    {
      Eigen::MatrixXd rotor_i_jacobian = Eigen::MatrixXd::Zero(6, model_->nv);
      pinocchio::computeFrameJacobian(*model_, *data_, q, model_->getFrameId("rotor" + std::to_string(i+1)), pinocchio::LOCAL, rotor_i_jacobian); // LOCAL

      // wrench generated by rotor is expressed LOCAL frame
      Eigen::VectorXd rotor_i_wrench = Eigen::VectorXd::Zero(6);
      rotor_i_wrench.head<3>() = Eigen::Vector3d(0, 0, thrust(i));
      rotor_i_wrench.tail<3>() = Eigen::Vector3d(0, 0, m_f_rate_ * thrust(i));

      Eigen::VectorXd rotor_i_general_force = rotor_i_jacobian.transpose() * rotor_i_wrench;
      rotor_general_force += rotor_i_general_force;

      // if(verbose)
      //   {
      //     std::cout << "rotor_" << i + 1 << "_jacobian: " << std::endl;
      //     std::cout << rotor_i_jacobian << std::endl;
      //     std::cout << "rotor_" << i + 1 << "_wrench: " << std::endl;
      //     std::cout << rotor_i_wrench.transpose() << std::endl;
      //     std::cout << "rotor_" << i + 1 << "_general_force: " << std::endl;
      //     std::cout << rotor_i_general_force.transpose() << std::endl;
      //     std::cout << std::endl;
      //   }
    }

  if(verbose)
    {
      // std::cout << "M: " << std::endl;
      // std::cout << M << std::endl;
      // std::cout << "M * a" << std::endl;
      // std::cout << (M * a).transpose() << std::endl;
      // std::cout << "g: " << std::endl;
      // std::cout << g.transpose() << std::endl;
      // std::cout << "M * a + g: " << std::endl;
      // std::cout << (M * a + g).transpose() << std::endl;
      // std::cout << "Cv: " << std::endl;
      // std::cout << Cv.transpose() << std::endl;
      std::cout << "M * a + Cv + g: " << std::endl;
      std::cout << (M * a + Cv + g).transpose() << std::endl;
      std::cout << std::endl;
      std::cout << "rotor_general_force: " << std::endl;
      std::cout << rotor_general_force.transpose() << std::endl;
      std::cout << "tau + rotor_general_force: " << std::endl;
      std::cout << (tau + rotor_general_force).transpose() << std::endl;
      std::cout << "error norm: " << (M * a + Cv + g - (tau + rotor_general_force)).norm() << std::endl;
  }

  return (M * a + Cv + g).isApprox(tau + rotor_general_force, 1e-6);
}

bool PinocchioRobotModel::forwardDynamicsDerivativesTest(bool verbose)
{
  Eigen::VectorXd q = pinocchio::randomConfiguration(*model_);
  Eigen::VectorXd v = Eigen::VectorXd::Ones(model_->nv);
  Eigen::VectorXd tau = Eigen::VectorXd::Ones(model_->nv);
  Eigen::VectorXd thrust = Eigen::VectorXd::Ones(rotor_num_);

  addNoise(v, 0.1);
  addNoise(tau, 0.1);
  addNoise(thrust, 0.1);

  // normal ABA Derivatives
  auto start = std::chrono::high_resolution_clock::now();
  pinocchio::computeABADerivatives(*model_, *data_, q, v, tau);
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "ABADrivatives time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  Eigen::MatrixXd aba_partial_dq = data_->ddq_dq;
  Eigen::MatrixXd aba_partial_dv = data_->ddq_dv;
  Eigen::MatrixXd aba_partial_dtau = data_->Minv;

  // ABA Derivatives with thrust
  start = std::chrono::high_resolution_clock::now();
  Eigen::MatrixXd aba_thrust_partial_dthrust = this->forwardDynamicsDerivatives(q, v, tau, thrust);
  end = std::chrono::high_resolution_clock::now();
  std::cout << "ABA with thrust Derivatives time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  Eigen::MatrixXd aba_thrust_partial_dq = data_->ddq_dq;
  Eigen::MatrixXd aba_thrust_partial_dv = data_->ddq_dv;
  Eigen::MatrixXd aba_thrust_partial_dtau = data_->Minv;

  if(verbose)
    {
      std::cout << "q: " << q.transpose() << std::endl;
      std::cout << "v: " << v.transpose() << std::endl;
      std::cout << "tau: " << tau.transpose() << std::endl;
      std::cout << "thrust: " << thrust.transpose() << std::endl;

      std::cout << "aba_partial_dq: " << std::endl;
      std::cout << aba_partial_dq << std::endl;
      std::cout << "aba_thrust_partial_dq: " << std::endl;
      std::cout << aba_thrust_partial_dq << std::endl;
      std::cout << "aba_partial_dv: " << std::endl;
      std::cout << aba_partial_dv << std::endl;
      std::cout << "aba_partial_dtau: " << std::endl;
      std::cout << aba_partial_dtau << std::endl;
      std::cout << "aba_thrust_partial_dthrust: " << std::endl;
      std::cout << aba_thrust_partial_dthrust << std::endl;

      std::cout << "aba_partial_dq is changed by thrust: ";
      std::cout << !(aba_partial_dq.isApprox(aba_thrust_partial_dq, 1e-6)) << std::endl;
      std::cout << "aba_partial_dv is changed by thrust: ";
      std::cout << !(aba_partial_dv.isApprox(aba_thrust_partial_dv, 1e-6)) << std::endl;
      std::cout << "aba_partial_dtau is changed by thrust: ";
      std::cout << !(aba_partial_dtau.isApprox(aba_thrust_partial_dtau, 1e-6)) << std::endl;
    }

  // compare with numerical derivative
  double epsilon = 1e-6;
  Eigen::VectorXd original_thrust = thrust;
  Eigen::VectorXd original_a = this->forwardDynamics(q, v, tau, original_thrust);
  Eigen::MatrixXd aba_thrust_partial_dthrust_num = Eigen::MatrixXd::Zero(model_->nv, rotor_num_);
  for(int i = 0; i < rotor_num_; i++)
    {
      thrust = original_thrust;
      thrust(i) += epsilon;
      Eigen::VectorXd a_plus = this->forwardDynamics(q, v, tau, thrust);
      aba_thrust_partial_dthrust_num.col(i) = (a_plus - original_a) / epsilon;
    }

  if(verbose)
    {
      std::cout << "aba_thrust_partial_dthrust numerical: " << std::endl;
      std::cout << aba_thrust_partial_dthrust_num << std::endl;
    }

  return (aba_thrust_partial_dthrust.isApprox(aba_thrust_partial_dthrust_num, 1e-6));
}

bool PinocchioRobotModel::inverseDynamicsTest(bool verbose)
{
  Eigen::VectorXd q = this->getResetConfiguration();
  Eigen::VectorXd v = Eigen::VectorXd::Zero(model_->nv);
  Eigen::VectorXd a = Eigen::VectorXd::Zero(model_->nv);

  addNoise(v, 0.1);
  addNoise(a, 0.1);

  auto start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd tau = pinocchio::rnea(*model_, *data_, q, v, a);
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "RNEA time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd tau_thrust = this->inverseDynamics(q, v, a);
  end = std::chrono::high_resolution_clock::now();
  std::cout << "ID time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  if(verbose)
    {
      std::cout << "q: " << std::endl;
      std::cout << q.transpose() << std::endl;
      std::cout << "v: " << std::endl;
      std::cout << v.transpose() << std::endl;
      std::cout << "a: " << std::endl;
      std::cout << a.transpose() << std::endl;
      std::cout << "tau: " << std::endl;
      std::cout << tau.transpose() << std::endl;
      std::cout << "tau_thrust: " << std::endl;
      std::cout << tau_thrust.transpose() << std::endl;
    }

  // check with result of fd
  Eigen::VectorXd thrust = tau_thrust.tail(rotor_num_);

  Eigen::VectorXd a_fd = this->forwardDynamics(q, v, tau_thrust.head(model_->nv), thrust);

  if(verbose)
    {
      std::cout << "a_fd: " << std::endl;
      std::cout << a_fd.transpose() << std::endl;
      std::cout << "error norm: " << (a - a_fd).norm() << std::endl;
    }

  return ((a - a_fd).array().abs() < 1e-4).all();
}

bool PinocchioRobotModel::inverseDynamicsDerivativesTest(bool verbose)
{
  Eigen::VectorXd q = this->getResetConfiguration();
  Eigen::VectorXd v = Eigen::VectorXd::Zero(model_->nv);
  Eigen::VectorXd a = Eigen::VectorXd::Zero(model_->nv);

  addNoise(v, 0.1);
  addNoise(a, 0.1);

  Eigen::MatrixXd id_partial_dq_ana = Eigen::MatrixXd::Zero(model_->nv + rotor_num_, model_->nv);
  Eigen::MatrixXd id_partial_dv_ana = Eigen::MatrixXd::Zero(model_->nv + rotor_num_, model_->nv);
  Eigen::MatrixXd id_partial_da_ana = Eigen::MatrixXd::Zero(model_->nv + rotor_num_, model_->nv);

  auto start = std::chrono::high_resolution_clock::now();
  pinocchio::computeRNEADerivatives(*model_, *data_, q, v, a);
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "RNEA Derivatives time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  start = std::chrono::high_resolution_clock::now();
  this->inverseDynamicsDerivatives(q, v, a, id_partial_dq_ana, id_partial_dv_ana, id_partial_da_ana);
  end = std::chrono::high_resolution_clock::now();
  std::cout << "ID Derivatives time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  if(verbose)
    {
      std::cout << "q: " << std::endl;
      std::cout << q.transpose() << std::endl;
      std::cout << "v: " << std::endl;
      std::cout << v.transpose() << std::endl;
      std::cout << "a: " << std::endl;
      std::cout << a.transpose() << std::endl;
    }

    // compare with numerical derivative
    double epsilon = 1e-6;
    Eigen::VectorXd original_q = q;
    Eigen::VectorXd original_v = v;
    Eigen::VectorXd original_a = a;
    Eigen::VectorXd id_original_solution = this->inverseDynamics(original_q, original_v, original_a);

    // check partial_dq
    Eigen::MatrixXd id_partial_dq_num = Eigen::MatrixXd::Zero(model_->nv + rotor_num_, model_->nv);
    for(int i = 0; i < 3; i++) // root link position
    {
      q = original_q;
      q(i) += epsilon;
      Eigen::VectorXd id_solution_plus = this->inverseDynamics(q, original_v, original_a);
      id_partial_dq_num.col(i) = (id_solution_plus - id_original_solution) / epsilon;
    }

    for(int i = 0; i < 3; i++) // root link quaternion
    {
        q = original_q;
        double d_roll = i == 0 ? epsilon : 0; Eigen::AngleAxisd roll(Eigen::AngleAxisd(d_roll, Eigen::Vector3d::UnitX()));
        double d_pitch = i == 1 ? epsilon : 0; Eigen::AngleAxisd pitch(Eigen::AngleAxisd(d_pitch, Eigen::Vector3d::UnitY()));
        double d_yaw = i == 2 ? epsilon : 0; Eigen::AngleAxisd yaw(Eigen::AngleAxisd(d_yaw, Eigen::Vector3d::UnitZ()));

        Eigen::Matrix3d dR = pinocchio::exp3(Eigen::Vector3d(d_roll, d_pitch, d_yaw));
        Eigen::Quaterniond dQuat(dR);
        Eigen::Quaterniond original_quat = Eigen::Quaterniond(original_q(6), original_q(3), original_q(4), original_q(5)); // w, x, y, z
        Eigen::Quaterniond new_quat = dQuat * original_quat;
        new_quat.normalize();

        q(3) = new_quat.x();
        q(4) = new_quat.y();
        q(5) = new_quat.z();
        q(6) = new_quat.w();

        Eigen::VectorXd id_solution_plus = this->inverseDynamics(q, original_v, original_a);
        id_partial_dq_num.col(i + 3) = (id_solution_plus - id_original_solution) / epsilon;
    }

    for(int i = 7; i < model_->nq; i++) // joint position
    {
      q = original_q;
      q(i) += epsilon;
      Eigen::VectorXd id_solution_plus = this->inverseDynamics(q, original_v, original_a);
      id_partial_dq_num.col(i - 1) = (id_solution_plus - id_original_solution) / epsilon;
    }

    // check partial_dv
    this->inverseDynamics(original_q, original_v, original_a);
    Eigen::MatrixXd id_partial_dv_num = Eigen::MatrixXd::Zero(model_->nv + rotor_num_, model_->nv);
    for(int i = 0; i < model_->nv; i++)
    {
      v = original_v;
      v(i) += epsilon;
      Eigen::VectorXd id_solution_plus = this->inverseDynamics(original_q, v, original_a);
      id_partial_dv_num.col(i) = (id_solution_plus - id_original_solution) / epsilon;
    }

    // check partial_da
    this->inverseDynamics(original_q, original_v, original_a);
    Eigen::MatrixXd id_partial_da_num = Eigen::MatrixXd::Zero(model_->nv + rotor_num_, model_->nv);
    for(int i = 0; i < model_->nv; i++)
    {
      a = original_a;
      a(i) += epsilon;
      Eigen::VectorXd id_solution_plus = this->inverseDynamics(original_q, original_v, a);
      id_partial_da_num.col(i) = (id_solution_plus - id_original_solution) / epsilon;
    }

    if(verbose)
    {
        // std::cout << "id_partial_dq_ana: " << std::endl;
        // std::cout << id_partial_dq_ana << std::endl;
        // std::cout << "id_partial_dq num: " << std::endl;
        // std::cout << id_partial_dq_num << std::endl;

        // std::cout << "id_partial_dv_ana: " << std::endl;
        // std::cout << id_partial_dv_ana << std::endl;
        // std::cout << "id_partial_dv num: " << std::endl;
        // std::cout << id_partial_dv_num << std::endl;

        // std::cout << "id_partial_da_ana: " << std::endl;
        // std::cout << id_partial_da_ana << std::endl;
        // std::cout << "id_partial_da num: " << std::endl;
        // std::cout << id_partial_da_num << std::endl;

        std::cout << "diff of id_partial_dq:" << std::endl;
        std::cout << id_partial_dq_ana - id_partial_dq_num << std::endl;
        std::cout << "norm: " << (id_partial_dq_ana - id_partial_dq_num).norm() << " max diff: " << (id_partial_dq_ana - id_partial_dq_num).cwiseAbs().maxCoeff() << std::endl;

        std::cout << "diff of id_partial_dv:" << std::endl;
        std::cout << id_partial_dv_ana - id_partial_dv_num << std::endl;
        std::cout << "norm: " << (id_partial_dv_ana - id_partial_dv_num).norm() << " max diff: " << (id_partial_dv_ana - id_partial_dv_num).cwiseAbs().maxCoeff() << std::endl;

        std::cout << "diff of id_partial_da:" << std::endl;
        std::cout << id_partial_da_ana - id_partial_da_num << std::endl;
        std::cout << "norm: " << (id_partial_da_ana - id_partial_da_num).norm() << " max diff: " << (id_partial_da_ana - id_partial_da_num).cwiseAbs().maxCoeff() << std::endl;
    }

  return (id_partial_dq_ana - id_partial_dq_num).cwiseAbs().maxCoeff() < 1e-4 &&
         (id_partial_dv_ana - id_partial_dv_num).cwiseAbs().maxCoeff() < 1e-4 &&
         (id_partial_da_ana - id_partial_da_num).cwiseAbs().maxCoeff() < 1e-4;
}

bool PinocchioRobotModel::computeTauExtByThrustDerivativeQDerivativesTest(bool verbose)
{
  Eigen::VectorXd q = this->getResetConfiguration();

  std::vector<Eigen::MatrixXd> tauext_partial_thrust_partial_q_ana = this->computeTauExtByThrustDerivativeQDerivatives(q); // compute analytical derivatives
  std::vector<Eigen::MatrixXd> tauext_partial_thrust_partial_q_num = this->computeTauExtByThrustDerivativeQDerivativesNum(q); // compute numerical derivatives

  if(verbose)
  {
      for(int i = 0; i < tauext_partial_thrust_partial_q_ana.size(); i++)
      {
          std::cout << "tauext_partial_thrust_partial_q_ana[" << i << "]" << std::endl;
          std::cout << tauext_partial_thrust_partial_q_ana.at(i) << std::endl;
          std::cout << "tauext_partial_thrust_partial_q_num[" << i << "]" << std::endl;
          std::cout << tauext_partial_thrust_partial_q_num.at(i) << std::endl;
      }
  }

  bool ok = true;
  for(int i = 0; i < model_->nv; i++)
    {

      if((tauext_partial_thrust_partial_q_ana.at(i) - tauext_partial_thrust_partial_q_num.at(i)).cwiseAbs().maxCoeff() > 1e-4)
        {
          std::cout << "tauext_partial_thrust_partial_q_ana[" << i << "] is not equal to tauext_partial_thrust_partial_q_num[" << i << "]" << std::endl;
          ok = false;
        }
    }
    return ok;
}