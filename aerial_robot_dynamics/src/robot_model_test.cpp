#include <aerial_robot_dynamics/robot_model.h>
#include <aerial_robot_dynamics/math_utils.h>
#include <chrono>

using namespace aerial_robot_dynamics;

Eigen::VectorXd PinocchioRobotModel::getResetConfiguration()
{
  Eigen::VectorXd q = Eigen::VectorXd::Zero(model_->nq);
  q(6) = 1;
  q(model_->joints[model_->getJointId("joint1_yaw")].idx_q()) = M_PI / 2.0;
  q(model_->joints[model_->getJointId("joint2_yaw")].idx_q()) = M_PI / 2.0;
  q(model_->joints[model_->getJointId("joint3_yaw")].idx_q()) = M_PI / 2.0;

  return q;
}


bool PinocchioRobotModel::forwardDynamicsTest(bool verbose)
{
  Eigen::VectorXd q = pinocchio::randomConfiguration(*model_);
  Eigen::VectorXd v = Eigen::VectorXd::Ones(model_->nv);
  Eigen::VectorXd tau = Eigen::VectorXd::Ones(model_->nv);
  Eigen::VectorXd thrust = Eigen::VectorXd::Ones(rotor_num_);

  addNoise(v, 0.1);
  addNoise(tau, 0.1);
  addNoise(thrust, 0.1);

  auto start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd a = this->forwardDynamics(q, v, tau, thrust); // calculate FD with thrust
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "FD time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  if(verbose)
    {
      std::cout << "q:" << std::endl;
      std::cout << q.transpose() << std::endl;
      std::cout << "v:" << std::endl;
      std::cout << v.transpose() << std::endl;
      std::cout << "tau:" << std::endl;
      std::cout << tau.transpose() << std::endl;
      std::cout << "thrust:" << std::endl;
      std::cout << thrust.transpose() << std::endl;
      std::cout << "a:" << std::endl;
      std::cout << a.transpose() << std::endl;
    }


  // calculate mass matrix
  pinocchio::crba(*model_, *data_, q);
  Eigen::MatrixXd M = data_->M;
  M.triangularView<Eigen::StrictlyLower>() = M.transpose();

  // calculate generalized gravity
  pinocchio::computeGeneralizedGravity(*model_, *data_, q);
  Eigen::VectorXd g = data_->g;

  // calculate coriolis and centrifugal forces
  pinocchio::nonLinearEffects(*model_, *data_, q, v);
  Eigen::VectorXd nle = data_->nle;
  Eigen::VectorXd Cv = nle - g;

  // calculate general force by rotors
  Eigen::VectorXd rotor_general_force = Eigen::VectorXd::Zero(model_->nv);
  for(int i = 0; i < rotor_num_; i++)
    {
      Eigen::MatrixXd rotor_i_jacobian = Eigen::MatrixXd::Zero(6, model_->nv);
      pinocchio::computeFrameJacobian(*model_, *data_, q, model_->getFrameId("rotor" + std::to_string(i+1)), pinocchio::LOCAL, rotor_i_jacobian); // LOCAL

      // wrench generated by rotor is expressed LOCAL frame
      Eigen::VectorXd rotor_i_wrench = Eigen::VectorXd::Zero(6);
      rotor_i_wrench.head<3>() = Eigen::Vector3d(0, 0, thrust(i));
      rotor_i_wrench.tail<3>() = Eigen::Vector3d(0, 0, m_f_rate_ * thrust(i));

      Eigen::VectorXd rotor_i_general_force = rotor_i_jacobian.transpose() * rotor_i_wrench;
      rotor_general_force += rotor_i_general_force;

      // if(verbose)
      //   {
      //     std::cout << "rotor_" << i + 1 << "_jacobian: " << std::endl;
      //     std::cout << rotor_i_jacobian << std::endl;
      //     std::cout << "rotor_" << i + 1 << "_wrench: " << std::endl;
      //     std::cout << rotor_i_wrench.transpose() << std::endl;
      //     std::cout << "rotor_" << i + 1 << "_general_force: " << std::endl;
      //     std::cout << rotor_i_general_force.transpose() << std::endl;
      //     std::cout << std::endl;
      //   }
    }

  if(verbose)
    {
      // std::cout << "M: " << std::endl;
      // std::cout << M << std::endl;
      // std::cout << "M * a" << std::endl;
      // std::cout << (M * a).transpose() << std::endl;
      // std::cout << "g: " << std::endl;
      // std::cout << g.transpose() << std::endl;
      // std::cout << "M * a + g: " << std::endl;
      // std::cout << (M * a + g).transpose() << std::endl;
      // std::cout << "Cv: " << std::endl;
      // std::cout << Cv.transpose() << std::endl;
      std::cout << "M * a + Cv + g: " << std::endl;
      std::cout << (M * a + Cv + g).transpose() << std::endl;
      std::cout << std::endl;
      std::cout << "rotor_general_force: " << std::endl;
      std::cout << rotor_general_force.transpose() << std::endl;
      std::cout << "tau + rotor_general_force: " << std::endl;
      std::cout << (tau + rotor_general_force).transpose() << std::endl;
      std::cout << "error norm: " << (M * a + Cv + g - (tau + rotor_general_force)).norm() << std::endl;
  }

  return (M * a + Cv + g).isApprox(tau + rotor_general_force, 1e-6);
}

bool PinocchioRobotModel::inverseDynamicsTest(bool verbose)
{
  Eigen::VectorXd q = this->getResetConfiguration();
  Eigen::VectorXd v = Eigen::VectorXd::Zero(model_->nv);
  Eigen::VectorXd a = Eigen::VectorXd::Zero(model_->nv);

  addNoise(v, 0.1);
  addNoise(a, 0.1);

  auto start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd tau = pinocchio::rnea(*model_, *data_, q, v, a);
  auto end = std::chrono::high_resolution_clock::now();
  std::cout << "RNEA time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  start = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd tau_thrust = this->inverseDynamics(q, v, a);
  end = std::chrono::high_resolution_clock::now();
  std::cout << "ID time: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0 << " ms" << std::endl;

  if(verbose)
    {
      std::cout << "q: " << std::endl;
      std::cout << q.transpose() << std::endl;
      std::cout << "v: " << std::endl;
      std::cout << v.transpose() << std::endl;
      std::cout << "a: " << std::endl;
      std::cout << a.transpose() << std::endl;
      std::cout << "tau: " << std::endl;
      std::cout << tau.transpose() << std::endl;
      std::cout << "tau_thrust: " << std::endl;
      std::cout << tau_thrust.transpose() << std::endl;
    }

  // check with result of fd
  Eigen::VectorXd thrust = tau_thrust.tail(rotor_num_);

  Eigen::VectorXd a_fd = this->forwardDynamics(q, v, tau_thrust.head(model_->nv), thrust);

  if(verbose)
    {
      std::cout << "a_fd: " << std::endl;
      std::cout << a_fd.transpose() << std::endl;
      std::cout << "error norm: " << (a - a_fd).norm() << std::endl;
    }

  return ((a - a_fd).array().abs() < 1e-4).all();
}
